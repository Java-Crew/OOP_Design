## 1️⃣ 협력과 메시지

### 1. 클라이언트 - 서버 모델

- 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다.
- 이를 클라이언트 - 서버 모델이라고 부른다.
- 객체가 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 하는데, 이를 가능하게 하주는 매개체가 메시지다.

### 2. 메시지와 메시지 전송

- 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
- 다른 객체에게 도움을 요청하는 것을 메시지 전송이라고 한다.
- 이때 메시지를 전송하는 객체를 메시지 전송자라고 부르고 이를 수신하는 객체를 메시지 수신자라고 부른다.
- 메시지는 다음과 같이 구성된다.
    - 오퍼레이션명
    - 인자
- 메시지 전송은 다음과 같이 구성된다.
    - 메시지
    - 메시지 수신자
    

```kotlin
/수신자    /오퍼레이션명     /인자
condition.isSatisfiedBy(screening)
```

### 3. 메시지와 메서드

- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입에 따라 달라진다. (컴파일 시점과 실행 시점의 메시지 의미가 달라질 수 있다.)
- 이처럼 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.
- 이는 모호하다는 단점이 있지만, 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있다는 더 큰 장점이 있다. 필요에 따라서 메서드를 스스로 결정할 수 있는 자율권을 누린다.
- 결합도 ⬇️ —> 유연, 확장 가능 ⬆️

### 4. 퍼블릭 인터페이스와 오퍼레이션

- 객체의 내부 구현은 숨겨져 있기 때문에, 다른 객체와 의사소통하기 위해 외부에 공개하는 메시지의 집합을 `퍼블릭 인터페이스` 라고 부른다.
- 퍼블릭 인터페이스에 포함된 메시지는 `오퍼레이션`이라고 부른다. 이는 수행 가능한 어떤 행동에 대한 추상화다.
- 실제로 실행되는 코드를 메서드라고 부른다.

### 5. 시그니처

- 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 시그니처라고 부른다.

## 2️⃣ 인터페이스와 설계 품질

- 좋은 인터페이스란
    - 최소한의 인터페이스
        - 꼭 필요한 오퍼레이션만 포함
    - 추상적인 인터페이스
        - 어떻게 수행하는지가 아닌 무엇을 하는지를 표현

- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법들
    - 디미터 법칙
    - 묻지 말고 시켜라
    - 의도를 드러내는 인터페이스
    - 명령-쿼리 분리

### 1. 디미터 법칙

- 객체들의 협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다는 법칙
- 협력 경로를 제한한다는 뜻은 어떤 클래스 내부 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 하는 것이다.
    - this 객체
    - 매서드이 매개변수
    - this 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체
- 이를 통해 결합도를 낮출 수 있다.

아래 코드는 디미터 법칙을 위반하는 전형적인 코드이다.

```kotlin
screening.getMovie().getDiscountConditions()
```

위 코드처럼 객체의 내부 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지를 사용해야 한다.

### 2. 묻지 말고 시켜라

- 메시지 전송자는 수신자의 내부 상태를 묻지 말아야 한다.
- 메시지 수신자 내부 상태를 이용해 어떤 결정을 내리는 로직은 수시잔 내부에 존재해야 한다.

### 3. 의도를 드러내는 인터페이스

```kotlin
public class PeriodCondition {
	public boolean isSatisfiedByPeriod() {}
}

public class SequenceCondition {
	public boolean isSatisfiedBySequence() {}
}
```

위 코드는 좋은 코드가 아니다.

1. 메서드에 대해 제대로 커뮤니케이션하지 못한다. 두 메서드는 동일한 동작을 하는 메서드지만 사용하는 입장에서는 실제 코드를 봐야 알 수 있다.
2. 클라이언트가 협력하는 객체의 종률을 알 수 있어 캡슐화를 위반한다.

아래처럼 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓자. (의도를 드러내자.)

```kotlin
public interface DiscountCondition {
	public boolean isSatisfiedBy();
}
```

의도를 드러내는 오퍼레이션의 이름은 협력이라는 문맥을 잘 반영해야 한다. 즉 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 한다.

## 3️⃣ 원칙의 함정

- 디미터 법칙과 묻지 말고 시켜라 스타일은 객체의 퍼블릭 인터페이스를 깔끔하고 유연하게 만들 수 있는 훌륭한 설계 원칙이다.
- 하지만 절대적인 법칙이 아니다. 이러한 원칙을 맹목적으로 추종하고 억지로 끼워 맞추려고 노력하지 말아라.

### 1. 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다

```kotlin
IntStream.of(1, 15, 20, 3, 9).filter().distinct().count()
```

- 위 코드는 IntStream 의 내부 구조가 외부로 노출된 것이 아니라 다른 IntStream 으로 변환할 뿐이다. 따라서 하나 이상의 도트(.)를 사용했지만 디미트 법칙을 어긴것은 아니다.

### 2. 결합도와 응집도의 충돌

- 묻지 말고 시켜라와 디미터 법칙을 준수하는 것이 항상 긍정적인 결과로 이어지는 것은 아니다.
- 잘못하면 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다. 즉 객체는 상관 없는 책임을 떠안게 된다. (응집도가 낮아진다.)
- 따라서 객체에 알맞지 않은 책임이면 가끔씩 묻는 방법(수신자 상태에 직접 접근)을 사용하자.

## 4️⃣ 명령-쿼리 분리 원칙

- 명령 (=프로시저)
    - 객체의 상태를 수정하는 오퍼레이션
    - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 쿼리 (=함수)
    - 객체와 관련된 정보를 반환하는 오퍼레이션
    - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

부수효과 발생여부에 따라서 명령과 쿼리로 나뉜다.

명령과 쿼리를 분리해서 얻게 되는 장점은 무엇일까?

### 1. 반복 일정의 명령과 쿼리 분리하기

```java
public void reschedule(RecurringSchedule schedule) {
    from = LocalDateTime.of(from.toLocalDate().plusDays(daysDistance(schedule)), schedule.getFrom());
    duration = schedule.getDuration();
}

public boolean isSatisfied(RecurringSchedule schedule) {
    if (from.getDayOfWeek() != schedule.getDayOfWeek()) {
        reschedule(schedule);
        return false;
    }
    return true;
}
```

위 코드의 문제는 `isSatisfied` 메서드가 명령과 쿼리의 두 가지 역할을 동시에 수행한다는 점이다.만약 `reschedule()` 메서드 때문에 버그가 발생한다면 개발자는 버그의 원인을 찾기 힘들 것이다. 대부분의 사람들은 `isSatisfied` 메서드가 부수효과를 가질 것이라고 예상하지 못하기 때문이다. 

내부적으로 부수효과를 가지는 명령은 버그를 발생시킬 수 있기 때문에 쿼리와 분리해야 한다.

그러면 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월한 코드가 될 수 있다.

### 2. 명령-쿼리 분리와 참조 투명성

<aside>
💡 **참조 투명성이란?**
어떤 표현식 e가 있을 때 모든 e를 e의 값으로 바꾸더라도 결과가 달라지지 않는다.

</aside>

객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다.

하지만 명령-쿼리 분리 원칙을 사용하면 부수효과를 가지는 명령과 부수효과를 가지지 않는 쿼리로 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있다.

위의 `isSatisfied` 메서드를 어떤 순서로 몇 번 호출하건 상관없이 항상 결과는 동일하다.

### 3. 책임에 초점을 맞춰라

결국 책임 주도 설계 방법을 따르면 디미터 법칙, 묻지 말고 시켜라 스타일, 의도를 드러내는 인터페이스, 명령-쿼리 분리 원칙을 지키는 훌륭한 메시지를 얻을 수 있다.
